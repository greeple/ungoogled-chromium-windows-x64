diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -1,5 +1,6 @@
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
#include "chrome/browser/chrome_content_browser_client.h"
#include "base/command_line.h"
@@ -180,6 +181,28 @@
#include "chrome/browser/profiles/profile.h"
 
+// Domain overrides: includes and helpers
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/json/json_reader.h"
+#include "base/memory/raw_ptr.h"
+#include "base/strings/string_util.h"
+#include "base/values.h"
+#include "components/content_settings/core/browser/host_content_settings_map.h"
+#include "components/content_settings/core/browser/host_content_settings_map_factory.h"
+#include "components/content_settings/core/common/content_settings.h"
+#include "components/content_settings/core/common/content_settings_pattern.h"
+#include "net/http/http_request_headers.h"
+#include "services/network/public/cpp/resource_request.h"
+#include "third_party/blink/public/common/loader/url_loader_throttle.h"
+#include "url/gurl.h"
+
+namespace {
+
+constexpr char kDomainOverridesPrefPath[] = "profile.domain_overrides";
+
+}  // namespace
+
 // ... existing includes remain ...
 
@@ -400,6 +423,225 @@
 // ... existing code above ...
 
+namespace {
+
+// Минимальная реализация «опера‑подобных» доменных переопределений,
+// читаемых из JSON-файла Preferences.
+//
+// Формат (внутри корня "profile"):
+// "domain_overrides": {
+//   "[*.]site.ru": {
+//     "user_agent": "UA string",
+//     "javascript": "allow" | "block",
+//     "cookies": "allow" | "block"
+//   },
+//   "site.com": { ... }
+// }
+//
+// Рекомендуется ключи вида "[*.]example.com" для охвата поддоменов.
+
+enum class TriState { kUnset = 0, kAllow, kBlock };
+
+TriState ParseTri(const std::string* v) {
+  if (!v) return TriState::kUnset;
+  if (base::EqualsCaseInsensitiveASCII(*v, "allow")) return TriState::kAllow;
+  if (base::EqualsCaseInsensitiveASCII(*v, "block")) return TriState::kBlock;
+  return TriState::kUnset;
+}
+
+ContentSetting ToContentSetting(TriState t) {
+  switch (t) {
+    case TriState::kAllow: return CONTENT_SETTING_ALLOW;
+    case TriState::kBlock: return CONTENT_SETTING_BLOCK;
+    case TriState::kUnset: return CONTENT_SETTING_DEFAULT;
+  }
+  return CONTENT_SETTING_DEFAULT;
+}
+
+ContentSettingsPattern MakePattern(const std::string& key) {
+  // Сначала пытаемся как есть (поддерживает [*.] и шаблоны ContentSettingsPattern)
+  ContentSettingsPattern p = ContentSettingsPattern::FromString(key);
+  if (p.IsValid()) return p;
+  // Если это просто хост без схемы/пути — добавим [*.]
+  if (key.find("://") == std::string::npos && key.find('/') == std::string::npos) {
+    std::string fixed = key;
+    if (!base::StartsWith(key, "[*.]", base::CompareCase::SENSITIVE))
+      fixed = std::string("[*.]") + key;
+    p = ContentSettingsPattern::FromString(fixed);
+    if (p.IsValid()) return p;
+  }
+  // Вернем невалидный (не сработает ни на что).
+  return ContentSettingsPattern();
+}
+
+struct DomainOverrideEntry {
+  ContentSettingsPattern pattern;
+  std::string user_agent;  // пусто => нет подмены
+  TriState javascript = TriState::kUnset;
+  TriState cookies = TriState::kUnset;
+};
+
+class DomainOverridesData : public base::SupportsUserData::Data {
+ public:
+  static DomainOverridesData* GetForBrowserContext(content::BrowserContext* context) {
+    if (!context) return nullptr;
+    static const void* const kKey = &kKey;
+    auto* existing = static_cast<DomainOverridesData*>(context->GetUserData(kKey));
+    if (existing) return existing;
+    Profile* profile = Profile::FromBrowserContext(context);
+    auto owned = std::make_unique<DomainOverridesData>(profile);
+    auto* raw = owned.get();
+    context->SetUserData(kKey, std::move(owned));
+    return raw;
+  }
+
+  explicit DomainOverridesData(Profile* profile) : profile_(profile) {
+    LoadFromPreferencesFile();
+    ApplyContentSettings();
+  }
+
+  std::optional<std::string> GetUserAgentFor(const GURL& url) const {
+    if (!url.is_valid()) return std::nullopt;
+    for (const auto& e : entries_) {
+      if (!e.user_agent.empty() && e.pattern.Matches(url))
+        return e.user_agent;
+    }
+    return std::nullopt;
+  }
+
+ private:
+  void LoadFromPreferencesFile() {
+    entries_.clear();
+    if (!profile_) return;
+
+    // Путь к Preferences: <профиль>/Preferences
+    base::FilePath prefs_path = profile_->GetPath().Append(FILE_PATH_LITERAL("Preferences"));
+    std::string json;
+    if (!base::ReadFileToString(prefs_path, &json))
+      return;
+
+    auto parsed = base::JSONReader::Read(json);
+    if (!parsed || !parsed->is_dict())
+      return;
+    const base::Value::Dict& root = parsed->GetDict();
+    const base::Value::Dict* profile_dict = root.FindDict("profile");
+    if (!profile_dict)
+      return;
+    const base::Value::Dict* overrides = profile_dict->FindDict("domain_overrides");
+    if (!overrides)
+      return;
+
+    for (auto it = overrides->begin(); it != overrides->end(); ++it) {
+      std::string key = std::string(it->first);
+      const base::Value& v = it->second;
+      if (!v.is_dict())
+        continue;
+      ContentSettingsPattern pattern = MakePattern(key);
+      if (!pattern.IsValid())
+        continue;
+
+      DomainOverrideEntry e;
+      e.pattern = pattern;
+      const base::Value::Dict& d = v.GetDict();
+      if (const std::string* ua = d.FindString("user_agent"))
+        e.user_agent = *ua;
+      e.javascript = ParseTri(d.FindString("javascript"));
+      e.cookies = ParseTri(d.FindString("cookies"));
+      entries_.push_back(std::move(e));
+    }
+  }
+
+  void ApplyContentSettings() {
+    if (!profile_) return;
+    HostContentSettingsMap* map =
+        HostContentSettingsMapFactory::GetForProfile(profile_);
+    const auto wildcard = ContentSettingsPattern::Wildcard();
+
+    for (const auto& e : entries_) {
+      if (e.javascript != TriState::kUnset) {
+        map->SetContentSettingCustomScope(
+            e.pattern, wildcard, ContentSettingsType::JAVASCRIPT,
+            ToContentSetting(e.javascript));
+      }
+      if (e.cookies != TriState::kUnset) {
+        map->SetContentSettingCustomScope(
+            e.pattern, wildcard, ContentSettingsType::COOKIES,
+            ToContentSetting(e.cookies));
+      }
+    }
+  }
+
+  raw_ptr<Profile> profile_ = nullptr;
+  std::vector<DomainOverrideEntry> entries_;
+};
+
+class UAHeaderOverrideThrottle : public blink::URLLoaderThrottle {
+ public:
+  explicit UAHeaderOverrideThrottle(DomainOverridesData* data) : data_(data) {}
+  ~UAHeaderOverrideThrottle() override = default;
+
+  void WillStartRequest(network::ResourceRequest* request, bool* /*defer*/) override {
+    if (!data_ || !request) return;
+    if (auto ua = data_->GetUserAgentFor(request->url)) {
+      request->headers.SetHeader(net::HttpRequestHeaders::kUserAgent, *ua);
+    }
+  }
+
+  void WillRedirectRequest(net::RedirectInfo* redirect_info,
+                           const network::mojom::URLResponseHead& /*response_head*/,
+                           bool* /*defer*/,
+                           std::vector<std::string>* /*to_be_removed_headers*/,
+                           net::HttpRequestHeaders* modified_headers) override {
+    if (!data_ || !redirect_info || !modified_headers) return;
+    if (auto ua = data_->GetUserAgentFor(redirect_info->new_url)) {
+      modified_headers->SetHeader(net::HttpRequestHeaders::kUserAgent, *ua);
+    }
+  }
+
+ private:
+  raw_ptr<DomainOverridesData> data_ = nullptr;
+};
+
+}  // namespace
+
 // ... existing code ...
 
 std::vector<std::unique_ptr<blink::URLLoaderThrottle>>
 ChromeContentBrowserClient::CreateURLLoaderThrottles(
     const network::ResourceRequest& request,
     content::BrowserContext* browser_context,
     content::RenderFrameHost* render_frame_host) {
   auto throttles = content::ContentBrowserClient::CreateURLLoaderThrottles(
       request, browser_context, render_frame_host);
+
+  // Добавим троттл для подмены UA согласно profile.domain_overrides
+  if (browser_context) {
+    if (auto* data = DomainOverridesData::GetForBrowserContext(browser_context)) {
+      throttles.push_back(std::make_unique<UAHeaderOverrideThrottle>(data));
+    }
+  }
   // ... existing logic ...
   return throttles;
 }
 
 void ChromeContentBrowserClient::WillCreateURLLoaderFactory(
     content::BrowserContext* browser_context,
     content::RenderFrameHost* render_frame_host,
     int render_process_id,
     URLLoaderFactoryType type,
     const url::Origin& request_initiator,
     const base::UnguessableToken& top_frame_token,
     mojo::PendingReceiver<network::mojom::URLLoaderFactory>* factory_receiver,
     mojo::PendingRemote<network::mojom::TrustedURLLoaderHeaderClient>*
         header_client,
     std::vector<std::unique_ptr<blink::URLLoaderThrottle>>* throttles) {
   // ... existing logic ...
+  // И для фабрик (подресурсы/навигации) тоже добавим троттл UA
+  if (browser_context && throttles) {
+    if (auto* data = DomainOverridesData::GetForBrowserContext(browser_context)) {
+      throttles->push_back(std::make_unique<UAHeaderOverrideThrottle>(data));
+    }
+  }
 }
 
 // ... rest of file ...
